<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · Pseudospectra.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Pseudospectra.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Pseudospectra.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../usage.html">Usage</a></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href="public.html">Public</a><ul class="internal"><li><a class="tocitem" href="#Simple-spectral-portrait"><span>Simple spectral portrait</span></a></li><li><a class="tocitem" href="#Importing-a-matrix-or-operator"><span>Importing a matrix or operator</span></a></li><li><a class="tocitem" href="#Setting-up-graphics-subsystem"><span>Setting up graphics subsystem</span></a></li><li><a class="tocitem" href="#Driver-function"><span>Driver function</span></a></li><li><a class="tocitem" href="#Pseudospectra-computation"><span>Pseudospectra computation</span></a></li><li><a class="tocitem" href="#Eigen/Pseudo-mode-computation-and-plotting"><span>Eigen/Pseudo-mode computation and plotting</span></a></li><li><a class="tocitem" href="#Other-computations"><span>Other computations</span></a></li><li><a class="tocitem" href="#Other-plots"><span>Other plots</span></a></li></ul></li><li><a class="tocitem" href="internals.html">Internals</a></li><li><a class="tocitem" href="demos.html">Example matrix generators</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="public.html">Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="public.html">Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RalphAS/Pseudospectra.jl/blob/master/docs/src/lib/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-interface"><a class="docs-heading-anchor" href="#Public-interface">Public interface</a><a id="Public-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-interface" title="Permalink"></a></h1><h2 id="Simple-spectral-portrait"><a class="docs-heading-anchor" href="#Simple-spectral-portrait">Simple spectral portrait</a><a id="Simple-spectral-portrait-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-spectral-portrait" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.spectralportrait" href="#Pseudospectra.spectralportrait"><code>Pseudospectra.spectralportrait</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spectralportrait(A::AbstractMatrix; npts=100) =&gt; Plots object</code></pre><p>compute pseudospectra of matrix <code>A</code> and display as a spectral portrait.</p><p>Pseudospectra are computed on a grid of <code>npts</code> by <code>npts</code> points in the complex plane, including a neighborhood of the spectrum. Contour levels are <code>log10(ϵ)</code> where <code>ϵ</code> is the inverse resolvent norm. This is a convenience wrapper for simple cases; see the Pseudospectra package documentation for more elaborate interfaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/Pseudospectra.jl#L691-L701">source</a></section></article><h2 id="Importing-a-matrix-or-operator"><a class="docs-heading-anchor" href="#Importing-a-matrix-or-operator">Importing a matrix or operator</a><a id="Importing-a-matrix-or-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Importing-a-matrix-or-operator" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.new_matrix" href="#Pseudospectra.new_matrix"><code>Pseudospectra.new_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">new_matrix(A::AbstractMatrix, opts::Dict{Symbol,Any}=()) -&gt; ps_data</code></pre><p>process a matrix into the auxiliary data structure used by Pseudospectra.</p><p><strong>Options</strong></p><ul><li><code>:direct::Bool</code>: force use of a direct algorithm?</li><li><code>:keep_sparse::Bool</code>: use sparse matrix code even if <code>A</code> is not large?</li><li><code>:real_matrix::Bool</code>: treat <code>A</code> as unitarily equivalent to a real matrix?</li><li><code>:verbosity::Int</code>: obvious</li><li><code>:eigA</code>: eigenvalues of <code>A</code>, if already known</li><li><code>:proj_lev</code>: projection level (see <code>psa_compute</code>)</li><li><code>:npts</code>: edge length of grid for computing and plotting pseudospectra</li><li><code>:arpack_opts::ArpackOptions</code>: (see type description)</li><li><code>:levels::Vector{Real}</code>: contour levels (if automatic choice is not wanted)</li><li><code>:ax::Vector{Real}(4)</code>: bounding box for computation <code>[xmin,xmax,ymin,ymax]</code></li><li><code>:scale_equal::Bool</code>: force isotropic axes for spectral portraits?</li><li><code>:threaded::Bool</code>: distribute <code>Z</code> values over Julia threads?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/Pseudospectra.jl#L119-L137">source</a></section><section><div><pre><code class="language-none">new_matrix(A, opts::Dict{Symbol,Any}=()) -&gt; ps_data</code></pre><p>process a linear operator object into the auxiliary data structure used by Pseudospectra.</p><p>There must be methods with <code>A</code> for <code>eltype</code>, <code>size</code>, and <code>mul!</code>. It is up to the user to make sure that <code>mul!</code> is consistent with any options passed to the iterative solver (see documentation for <a href="internals.html#Pseudospectra.xeigs"><code>xeigs</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/Pseudospectra.jl#L320-L329">source</a></section></article><h2 id="Setting-up-graphics-subsystem"><a class="docs-heading-anchor" href="#Setting-up-graphics-subsystem">Setting up graphics subsystem</a><a id="Setting-up-graphics-subsystem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-graphics-subsystem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.setpsplotter" href="#Pseudospectra.setpsplotter"><code>Pseudospectra.setpsplotter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setpsplotter(plotter::Symbol=:default)</code></pre><p>Select a plotting package for use with Pseudospectra.</p><p>Currently <code>:Plots</code> and <code>:PyPlot</code> are implemented. Defaults to <code>:Plots</code> unless PyPlot is already imported without Plots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/plotter.jl#L40-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.setgs" href="#Pseudospectra.setgs"><code>Pseudospectra.setgs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setgs(; headless=false, savefigs=true) =&gt; gs</code></pre><p>Construct a <code>GUIState</code> for subsequent use by Pseudospectra functions.</p><p>Assumes plotting package has been chosen via <code>setpsplotter()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/plotter.jl#L66-L72">source</a></section></article><h2 id="Driver-function"><a class="docs-heading-anchor" href="#Driver-function">Driver function</a><a id="Driver-function-1"></a><a class="docs-heading-anchor-permalink" href="#Driver-function" title="Permalink"></a></h2><p>After a matrix has been ingested into a <code>PSAStruct</code> and the graphics subsystem has been established, the following function will compute pseudospectra and plot a spectral portrait:</p><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.driver!" href="#Pseudospectra.driver!"><code>Pseudospectra.driver!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">driver!(ps_data, opts, gs=defaultgs(); revise_method=false)</code></pre><p>Compute pseudospectra and plot a spectral portrait.</p><p>If using an iterative method to get some eigenvalues and a projection, invokes that first.</p><p><strong>Arguments</strong></p><ul><li><code>ps_data::PSAStruct</code>: ingested matrix, as processed by <code>new_matrix</code></li><li><code>gs::GUIState</code>: object handling graphical output</li><li><code>opts::Dict{Symbol,Any}</code>:<ul><li><code>:ax</code>, axis limits (overrides value stored in <code>ps_data</code>).</li><li>other options passed to <code>redrawcontour</code>, <code>arnoldiplotter!</code></li></ul></li></ul><p>Note that many options stored in <code>ps_data</code> by <code>new_matrix()</code> influence the processing.</p><p>When revising a spectral portrait (<code>revise_method==true</code>), the following entries in <code>opts</code> also apply:</p><ul><li><code>:arpack_opts::ArpackOptions</code>,</li><li><code>:direct::Bool</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/Pseudospectra.jl#L386-L407">source</a></section></article><h2 id="Pseudospectra-computation"><a class="docs-heading-anchor" href="#Pseudospectra-computation">Pseudospectra computation</a><a id="Pseudospectra-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Pseudospectra-computation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.psa_compute" href="#Pseudospectra.psa_compute"><code>Pseudospectra.psa_compute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">psa_compute(T,npts,ax,eigA,opts,S=I) -&gt; (Z,x,y,levels,info,Tproj,eigAproj,algo)</code></pre><p>Compute pseudospectra of a (decomposed) matrix.</p><p>Uses a modified version of the code in <sup class="footnote-reference"><a id="citeref-Trefethen1999" href="#footnote-Trefethen1999">[Trefethen1999]</a></sup>. If the matrix <code>T</code> is upper triangular (e.g. from a Schur decomposition) the solver is much more efficient than otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>:      input matrix, usu. from <code>schur()</code></li><li><code>npts</code>:   grid will have <code>npts × npts</code> nodes</li><li><code>ax</code>:     axis on which to plot <code>[min_real, max_real, min_imag, max_imag]</code></li><li><code>eigA</code>:   eigenvalues of the matrix, usu. also produced by <code>schur()</code>. Pass an empty vector if unknown.</li><li><code>S</code>:    2nd matrix, if this is a generalized problem arising from an original rectangular matrix.</li><li><code>opts</code>: a <code>Dict{Symbol,Any}</code> holding options. Keys used here are as follows:</li></ul><table><tr><th style="text-align: left">Key</th><th style="text-align: left">Type</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>:levels</code></td><td style="text-align: left"><code>Vector{Real}</code></td><td style="text-align: left">auto</td><td style="text-align: left"><code>log10(ϵ)</code> for the desired ϵ levels</td></tr><tr><td style="text-align: left"><code>:recompute_levels</code></td><td style="text-align: left"><code>Bool</code></td><td style="text-align: left">true</td><td style="text-align: left">automatically recompute ϵ levels?</td></tr><tr><td style="text-align: left"><code>:real_matrix</code></td><td style="text-align: left"><code>Bool</code></td><td style="text-align: left"><code>eltype(A)&lt;:Real</code></td><td style="text-align: left">is the original matrix real? (Portrait is symmetric if so.) This is needed because <code>T</code> could be complex even if <code>A</code> was real.</td></tr><tr><td style="text-align: left"><code>:proj_lev</code></td><td style="text-align: left"><code>Real</code></td><td style="text-align: left">∞</td><td style="text-align: left">The proportion by which to extend the axes in all directions before projection. If negative, exclude subspace of eigenvalues smaller than inverse fraction. ∞ means no projection.</td></tr><tr><td style="text-align: left"><code>:scale_equal</code></td><td style="text-align: left"><code>Bool</code></td><td style="text-align: left">false</td><td style="text-align: left">force the grid to be isotropic?</td></tr><tr><td style="text-align: left"><code>:threaded</code></td><td style="text-align: left"><code>Bool</code></td><td style="text-align: left">false</td><td style="text-align: left">distribute computation over Julia threads?</td></tr></table><p><strong>Notes:</strong></p><ul><li>Projection is only done for square, dense matrices.  Projection for sparse matrices may be handled (outside this function) by a Krylov method which reduces the matrix to a projected Hessenberg form before invoking <code>psa_compute</code>.</li><li>This function does not compute generalized pseudospectra per se. They may be handled by pre- and post-processing.</li></ul><p><strong>Outputs:</strong></p><ul><li><code>Z</code>:         the singular values over the grid</li><li><code>x</code>:         the x coordinates of the grid lines</li><li><code>y</code>:         the y coordinates of the grid lines</li><li><code>levels</code>:   the levels used for the contour plot (if automatically calculated)</li><li><code>Tproj</code>:     the projected matrix (an alias to <code>T</code> if no projection was done)</li><li><code>eigAproj</code>:  eigenvalues projected onto</li><li><code>algo</code>: a Symbol indicating which algorithm was used</li><li><code>info</code>:      flag indicating where automatic level creation fails:</li></ul><table><tr><th style="text-align: left">info</th><th style="text-align: left">Meaning</th></tr><tr><td style="text-align: left">0</td><td style="text-align: left">No error</td></tr><tr><td style="text-align: left">-1</td><td style="text-align: left">No levels in range specified (either manually, or if matrix is too normal to show levels)</td></tr><tr><td style="text-align: left">-2</td><td style="text-align: left">Matrix is so non-normal that only zero singular values were found</td></tr><tr><td style="text-align: left">-3</td><td style="text-align: left">Computation cancelled</td></tr></table></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/compute.jl#L32-L86">source</a></section></article><h2 id="Eigen/Pseudo-mode-computation-and-plotting"><a class="docs-heading-anchor" href="#Eigen/Pseudo-mode-computation-and-plotting">Eigen/Pseudo-mode computation and plotting</a><a id="Eigen/Pseudo-mode-computation-and-plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Eigen/Pseudo-mode-computation-and-plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.modeplot" href="#Pseudospectra.modeplot"><code>Pseudospectra.modeplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modeplot(ps_data, pkey [,z])</code></pre><p>Extract and plot an eigenmode or pseudo-eigenmode for the matrix encapsulated in the Pseudospectra object <code>ps_data</code>. Use the value <code>z</code> if provided or prompt for one. If <code>pkey</code> is 1, find the pseudoeigenmode for <code>z</code>; otherwise find the eigenmode for the eigenvalue closest to <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/modes.jl#L15-L23">source</a></section></article><h2 id="Other-computations"><a class="docs-heading-anchor" href="#Other-computations">Other computations</a><a id="Other-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Other-computations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.psa_radius" href="#Pseudospectra.psa_radius"><code>Pseudospectra.psa_radius</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">psa_radius(A,ϵ [,d]) -&gt; r,z</code></pre><p>Compute ϵ-pseudospectral radius for a dense matrix.</p><p>Quadratically convergent two-way method to compute the ϵ-pseudospectral radius <code>r</code> of a dense matrix <code>A</code>. Also returns a vector <code>z</code> of points where the pseudospectrum intersects the circle of radius <code>r</code>. Uses the &quot;criss-cross&quot; algorithm of Overton and Mengi.</p><p>The ϵ-pseudospectral radius is</p><pre><code class="language-none">   maximum(abs(z)) for z s.t. minimum(σ(A-zI)) == ϵ</code></pre><p>Optional arg:</p><ul><li><code>d</code>: eigenvalues of A, if known in advance</li></ul><p>Keyword args:</p><ul><li>`verbosity: 0 for quiet, 1 for noise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/radius.jl#L14-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.psa_abscissa" href="#Pseudospectra.psa_abscissa"><code>Pseudospectra.psa_abscissa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">psa_abscissa(A,ϵ [,d]) -&gt; α,z</code></pre><p>Compute ϵ-pseudospectral abscissa for a dense matrix.</p><p>Quadratically convergent two-way method to compute the ϵ-pseudospectral abscissa <code>α</code> of a dense matrix <code>A</code>. Also returns a vector <code>z</code> of points where the pseudospectrum reaches the abscissa. Uses the criss-cross algorithm of Burke et al.</p><p>The ϵ-pseudospectral abscissa is</p><pre><code class="language-none">   maximum(real(z)) for z s.t. minimum(σ(A-zI)) == ϵ</code></pre><p>Optional arg:</p><ul><li><code>d</code>: eigenvalues of A, if known in advance</li></ul><p>Keyword args:</p><ul><li>`verbosity: 0 for quiet, 1 for noise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/abscissa.jl#L14-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.numerical_range" href="#Pseudospectra.numerical_range"><code>Pseudospectra.numerical_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">numerical_range(A, nstep=20) -&gt; Vector{Complex}</code></pre><p>Compute points along the numerical range of a matrix.</p><p>Note: this solves an eigensystem for each point, so may be expensive.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/numrange.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.numerical_abscissa" href="#Pseudospectra.numerical_abscissa"><code>Pseudospectra.numerical_abscissa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">numerical_abscissa(A)</code></pre><p>Compute the numerical abscissa of a matrix <code>A</code>, <code>ω(A)</code>.</p><p>Uses <code>eigvals()</code>. <code>ω(A)</code> provides bounds and limiting behavior for <code>opnorm(exp(t*A))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/numrange.jl#L81-L88">source</a></section></article><h2 id="Other-plots"><a class="docs-heading-anchor" href="#Other-plots">Other plots</a><a id="Other-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Other-plots" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.surfplot" href="#Pseudospectra.surfplot"><code>Pseudospectra.surfplot</code></a> — <span class="docstring-category">Function</span></header><section><div><p>make a surface plot of the current spectral portrait</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/PseudospectraPlots.jl#L155-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.mtxexpsplot" href="#Pseudospectra.mtxexpsplot"><code>Pseudospectra.mtxexpsplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mtxexpsplot(ps_data,dt=0.1,nmax=50; gs::GUIState = defaultgs(), gradual=false)</code></pre><p>plot the evolution of <code>∥e^(tA)∥</code>.</p><p>This is useful for analyzing linear initial value problems <code>∂x/∂t = Ax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/Pseudospectra.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pseudospectra.mtxpowersplot" href="#Pseudospectra.mtxpowersplot"><code>Pseudospectra.mtxpowersplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mtxpowersplot(ps_data, nmax=50; gs::GUIState = defaultgs(), gradual=false)</code></pre><p>plot norms of powers of a matrix <code>∥A^k∥</code></p><p>This is useful for analyzing iterative linear algebra methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/a347e38cbba57be9a4d994afeec31b09a904536d/src/Pseudospectra.jl#L93-L99">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Trefethen1999"><a class="tag is-link" href="#citeref-Trefethen1999">Trefethen1999</a>L.N.Trefethen, &quot;Computation of pseudospectra,&quot; Acta Numerica 8, 247-295 (1999).</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage.html">« Usage</a><a class="docs-footer-nextpage" href="internals.html">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 5 December 2022 01:10">Monday 5 December 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
