<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · Pseudospectra.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Pseudospectra.jl logo"/></a><h1>Pseudospectra.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../usage.html">Usage</a></li><li><span class="toctext">Library</span><ul><li class="current"><a class="toctext" href="public.html">Public</a><ul class="internal"><li><a class="toctext" href="#Importing-a-matrix-or-operator-1">Importing a matrix or operator</a></li><li><a class="toctext" href="#Setting-up-graphics-subsystem-1">Setting up graphics subsystem</a></li><li><a class="toctext" href="#Driver-function-1">Driver function</a></li><li><a class="toctext" href="#Pseudospectra-computation-1">Pseudospectra computation</a></li><li><a class="toctext" href="#Eigen/Pseudo-mode-computation-and-plotting-1">Eigen/Pseudo-mode computation and plotting</a></li><li><a class="toctext" href="#Other-computations-1">Other computations</a></li><li><a class="toctext" href="#Other-plots-1">Other plots</a></li></ul></li><li><a class="toctext" href="internals.html">Internals</a></li><li><a class="toctext" href="demos.html">Example matrix generators</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="public.html">Public</a></li></ul><a class="edit-page" href="https://github.com/RalphAS/Pseudospectra.jl/blob/master/docs/src/lib/public.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Public</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-interface-1" href="#Public-interface-1">Public interface</a></h1><h2><a class="nav-anchor" id="Importing-a-matrix-or-operator-1" href="#Importing-a-matrix-or-operator-1">Importing a matrix or operator</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.new_matrix" href="#Pseudospectra.new_matrix"><code>Pseudospectra.new_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">new_matrix(A::AbstractMatrix, opts::Dict{Symbol,Any}=()) -&gt; ps_data</code></pre><p>process a matrix into the auxiliary data structure used by Pseudospectra.</p><p><strong>Options</strong></p><ul><li><code>:direct::Bool</code>: force use of a direct algorithm?</li><li><code>:keep_sparse::Bool</code>: use sparse matrix code even if <code>A</code> is not large?</li><li><code>:real_matrix::Bool</code>: treat <code>A</code> as unitarily equivalent to a real matrix?</li><li><code>:verbosity::Int</code>: obvious</li><li><code>:eigA</code>: eigenvalues of <code>A</code>, if already known</li><li><code>:proj_lev</code>: projection level (see <code>psa_compute</code>)</li><li><code>:npts</code>: edge length of grid for computing and plotting pseudospectra</li><li><code>:arpack_opts::ArpackOptions</code>: (see type description)</li><li><code>:levels::Vector{Real}</code>: contour levels</li><li><code>:ax::Vector{Real}(4)</code>: bounding box for computation <code>[xmin,xmax,ymin,ymax]</code></li><li><code>:scale_equal::Bool</code>: force isotropic axes for spectral portraits?</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/Pseudospectra.jl#L118-L135">source</a><div><div><pre><code class="language-none">new_matrix(A, opts::Dict{Symbol,Any}=()) -&gt; ps_data</code></pre><p>process a linear operator object into the auxiliary data structure used by Pseudospectra.</p><p>There must be methods with <code>A</code> for <code>eltype</code>, <code>size</code>, and <code>mul!</code>. It is up to the user to make sure that <code>mul!</code> is consistent with any options passed to the iterative solver (see documentation for <a href="internals.html#Pseudospectra.xeigs"><code>xeigs</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/Pseudospectra.jl#L317-L326">source</a></section><h2><a class="nav-anchor" id="Setting-up-graphics-subsystem-1" href="#Setting-up-graphics-subsystem-1">Setting up graphics subsystem</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.setpsplotter" href="#Pseudospectra.setpsplotter"><code>Pseudospectra.setpsplotter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setpsplotter(plotter::Symbol=:default)</code></pre><p>Select a plotting package for use with Pseudospectra.</p><p>Currently <code>:Plots</code> and <code>:PyPlot</code> are implemented. Defaults to <code>:Plots</code> unless PyPlot is already imported without Plots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/plotter.jl#L30-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.setgs" href="#Pseudospectra.setgs"><code>Pseudospectra.setgs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setgs(; headless=false, savefigs=true) =&gt; gs</code></pre><p>Construct a <code>GUIState</code> for subsequent use by Pseudospectra functions.</p><p>Assumes plotting package has been chosen via <code>setpsplotter()</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/plotter.jl#L56-L62">source</a></section><h2><a class="nav-anchor" id="Driver-function-1" href="#Driver-function-1">Driver function</a></h2><p>After a matrix has been ingested into a <code>PSAStruct</code> and the graphics subsystem has been established, the following function will compute pseudospectra and plot a spectral portrait:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.driver!" href="#Pseudospectra.driver!"><code>Pseudospectra.driver!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">driver!(ps_data, opts, gs=defaultgs(); revise_method=false)</code></pre><p>Compute pseudospectra and plot a spectral portrait.</p><p>If using an iterative method to get some eigenvalues and a projection, invokes that first.</p><p><strong>Arguments</strong></p><ul><li><code>ps_data::PSAStruct</code>: ingested matrix, as processed by <code>new_matrix</code></li><li><code>gs::GUIState</code>: object handling graphical output</li><li><code>opts::Dict{Symbol,Any}</code>:<ul><li><code>:ax</code>, axis limits (overrides value stored in <code>ps_data</code>).</li><li>other options passed to <code>redrawcontour</code>, <code>arnoldiplotter!</code></li></ul></li></ul><p>When revising a spectral portrait (<code>revise_method==true</code>), the following entries in <code>opts</code> also apply:</p><ul><li><code>:arpack_opts::ArpackOptions</code>,</li><li><code>:direct::Bool</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/Pseudospectra.jl#L382-L401">source</a></section><h2><a class="nav-anchor" id="Pseudospectra-computation-1" href="#Pseudospectra-computation-1">Pseudospectra computation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.psa_compute" href="#Pseudospectra.psa_compute"><code>Pseudospectra.psa_compute</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">psa_compute(T,npts,ax,eigA,opts,S=I) -&gt; (Z,x,y,levels,info,Tproj,eigAproj,algo)</code></pre><p>Compute pseudospectra of a (decomposed) matrix.</p><p>Uses a modified version of the code in <a href="#footnote-Trefethen1999">[Trefethen1999]</a>. If the matrix <code>T</code> is upper triangular (e.g. from a Schur decomposition) the solver is much more efficient than otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>:      input matrix, usu. from <code>schur()</code></li><li><code>npts</code>:   grid will have <code>npts × npts</code> nodes</li><li><code>ax</code>:     axis on which to plot <code>[min_real, max_real, min_imag, max_imag]</code></li><li><code>eigA</code>:   eigenvalues of the matrix, usu. also produced by <code>schur()</code>. Pass an empty vector if unknown.</li><li><code>S</code>:    2nd matrix, if this is a generalized problem arising from an original rectangular matrix.</li><li><code>opts</code>: a <code>Dict{Symbol,Any}</code> holding options. Keys used here are as follows:</li></ul><table><tr><th>Key</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td><code>:levels</code></td><td><code>Vector{Real}</code></td><td>auto</td><td><code>log10(ϵ)</code> for the desired ϵ levels</td></tr><tr><td><code>:recompute_levels</code></td><td><code>Bool</code></td><td>true</td><td>automatically recompute ϵ levels?</td></tr><tr><td><code>:real_matrix</code></td><td><code>Bool</code></td><td><code>eltype(A)&lt;:Real</code></td><td>is the original matrix real? (Portrait is symmetric if so.) This is needed because <code>T</code> could be complex even if <code>A</code> was real.</td></tr><tr><td><code>:proj_lev</code></td><td><code>Real</code></td><td>∞</td><td>The proportion by which to extend the axes in all directions before projection. If negative, exclude subspace of eigenvalues smaller than inverse fraction. ∞ means no projection.</td></tr><tr><td><code>:scale_equal</code></td><td><code>Bool</code></td><td>false</td><td>force the grid to be isotropic?</td></tr></table><p><strong>Notes:</strong></p><ul><li>Projection is only done for square, dense matrices.  Projection for sparse matrices may be handled (outside this function) by a Krylov method which reduces the matrix to a projected Hessenberg form before invoking <code>psa_compute</code>.</li><li>This function does not compute generalized pseudospectra per se. They may be handled by pre- and post-processing.</li></ul><p><strong>Outputs:</strong></p><ul><li><code>Z</code>:         the singular values over the grid</li><li><code>x</code>:         the x coordinates of the grid lines</li><li><code>y</code>:         the y coordinates of the grid lines</li><li><code>levels</code>:   the levels used for the contour plot (if automatically calculated)</li><li><code>Tproj</code>:     the projected matrix (an alias to <code>T</code> if no projection was done)</li><li><code>eigAproj</code>:  eigenvalues projected onto</li><li><code>algo</code>: a Symbol indicating which algorithm was used</li><li><code>info</code>:      flag indicating where automatic level creation fails:</li></ul><table><tr><th>info</th><th>Meaning</th></tr><tr><td>0</td><td>No error</td></tr><tr><td>-1</td><td>No levels in range specified (either manually, or if matrix is too normal to show levels)</td></tr><tr><td>-2</td><td>Matrix is so non-normal that only zero singular values were found</td></tr><tr><td>-3</td><td>Computation cancelled</td></tr></table><div class="footnote" id="footnote-Trefethen1999"><a href="#footnote-Trefethen1999"><strong>[Trefethen1999]</strong></a><p>L.N.Trefethen, &quot;Computation of pseudospectra,&quot; Acta Numerica 8, 247-295 (1999).</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/compute.jl#L28-L81">source</a></section><h2><a class="nav-anchor" id="Eigen/Pseudo-mode-computation-and-plotting-1" href="#Eigen/Pseudo-mode-computation-and-plotting-1">Eigen/Pseudo-mode computation and plotting</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.modeplot" href="#Pseudospectra.modeplot"><code>Pseudospectra.modeplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modeplot(ps_data, pkey [,z])</code></pre><p>Extract and plot an eigenmode or pseudo-eigenmode for the matrix encapsulated in the Pseudospectra object <code>ps_data</code>. Use the value <code>z</code> if provided or prompt for one. If <code>pkey</code> is 1, find the pseudoeigenmode for <code>z</code>; otherwise find the eigenmode for the eigenvalue closest to <code>z</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/modes.jl#L15-L23">source</a></section><h2><a class="nav-anchor" id="Other-computations-1" href="#Other-computations-1">Other computations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.psa_radius" href="#Pseudospectra.psa_radius"><code>Pseudospectra.psa_radius</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">psa_radius(A,ϵ [,d]) -&gt; r,z</code></pre><p>Compute ϵ-pseudospectral radius for a dense matrix.</p><p>Quadratically convergent two-way method to compute the ϵ-pseudospectral radius <code>r</code> of a dense matrix <code>A</code>. Also returns a vector <code>z</code> of points where the pseudospectrum intersects the circle of radius <code>r</code>. Uses the &quot;criss-cross&quot; algorithm of Overton and Mengi.</p><p>The ϵ-pseudospectral radius is</p><pre><code class="language-none">   maximum(abs(z)) for z s.t. minimum(σ(A-zI)) == ϵ</code></pre><p>Optional arg:</p><ul><li><code>d</code>: eigenvalues of A, if known in advance</li></ul><p>Keyword args:</p><ul><li>`verbosity: 0 for quiet, 1 for noise</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/radius.jl#L14-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.psa_abscissa" href="#Pseudospectra.psa_abscissa"><code>Pseudospectra.psa_abscissa</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">psa_abscissa(A,ϵ [,d]) -&gt; α,z</code></pre><p>Compute ϵ-pseudospectral abscissa for a dense matrix.</p><p>Quadratically convergent two-way method to compute the ϵ-pseudospectral abscissa <code>α</code> of a dense matrix <code>A</code>. Also returns a vector <code>z</code> of points where the pseudospectrum reaches the abscissa. Uses the criss-cross algorithm of Burke et al.</p><p>The ϵ-pseudospectral abscissa is</p><pre><code class="language-none">   maximum(real(z)) for z s.t. minimum(σ(A-zI)) == ϵ</code></pre><p>Optional arg:</p><ul><li><code>d</code>: eigenvalues of A, if known in advance</li></ul><p>Keyword args:</p><ul><li>`verbosity: 0 for quiet, 1 for noise</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/abscissa.jl#L14-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.numerical_range" href="#Pseudospectra.numerical_range"><code>Pseudospectra.numerical_range</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numerical_range(A, nstep=20) -&gt; Vector{Complex}</code></pre><p>Compute points along the numerical range of a matrix.</p><p>Note: this solves an eigensystem for each point, so may be expensive.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/numrange.jl#L15-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.numerical_abscissa" href="#Pseudospectra.numerical_abscissa"><code>Pseudospectra.numerical_abscissa</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">numerical_abscissa(A)</code></pre><p>Compute the numerical abscissa of a matrix <code>A</code>, <code>ω(A)</code>.</p><p>Uses <code>eigvals()</code>. <code>ω(A)</code> provides bounds and limiting behavior for <code>norm(expm(t*A))</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/numrange.jl#L80-L87">source</a></section><h2><a class="nav-anchor" id="Other-plots-1" href="#Other-plots-1">Other plots</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.surfplot" href="#Pseudospectra.surfplot"><code>Pseudospectra.surfplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>make a surface plot of the current spectral portrait</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/PseudospectraPlots.jl#L151-L153">source</a><div><div><p>make a surface plot of the current spectral portrait</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/PseudospectraPlots.jl#L151-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.mtxexpsplot" href="#Pseudospectra.mtxexpsplot"><code>Pseudospectra.mtxexpsplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mtxexpsplot(ps_data,dt=0.1,nmax=50; gs::GUIState = defaultgs(), gradual=false)</code></pre><p>plot the evolution of <code>∥e^(tA)∥</code>.</p><p>This is useful for analyzing linear initial value problems <code>∂x/∂t = Ax</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/Pseudospectra.jl#L80-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Pseudospectra.mtxpowersplot" href="#Pseudospectra.mtxpowersplot"><code>Pseudospectra.mtxpowersplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mtxpowersplot(ps_data, nmax=50; gs::GUIState = defaultgs(), gradual=false)</code></pre><p>plot norms of powers of a matrix <code>∥A^k∥</code></p><p>This is useful for analyzing iterative linear algebra methods.</p></div></div><a class="source-link" target="_blank" href="https://github.com/RalphAS/Pseudospectra.jl/blob/5490516eeef64887b4c80287ed08e104008efd67/src/Pseudospectra.jl#L92-L98">source</a></section><footer><hr/><a class="previous" href="../usage.html"><span class="direction">Previous</span><span class="title">Usage</span></a><a class="next" href="internals.html"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
